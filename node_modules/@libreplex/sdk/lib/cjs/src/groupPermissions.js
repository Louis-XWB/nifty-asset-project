"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUserPermissionsForGroup = exports.getCollectionWideUserPermissionsAddress = exports.UserPermission = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const programs_1 = require("./programs");
var UserPermission;
(function (UserPermission) {
    UserPermission[UserPermission["Update"] = 0] = "Update";
    UserPermission[UserPermission["Delete"] = 1] = "Delete";
    UserPermission[UserPermission["AddToGroup"] = 2] = "AddToGroup";
})(UserPermission = exports.UserPermission || (exports.UserPermission = {}));
function getCollectionWideUserPermissionsAddress(collection, user, program = constants_1.LIBREPLEX_METADATA_PROGRAM_ID) {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("permissions"), user.toBuffer(), collection.toBuffer()], program)[0];
}
exports.getCollectionWideUserPermissionsAddress = getCollectionWideUserPermissionsAddress;
function convertPermission(p) {
    if (p === UserPermission.AddToGroup) {
        return {
            addToGroup: {}
        };
    }
    if (p === UserPermission.Delete) {
        return {
            addToGroup: {}
        };
    }
    if (p === UserPermission.Update) {
        return {
            addToGroup: {}
        };
    }
    throw new Error("Invalid permission enum");
}
function setUserPermissionsForGroup({ connector, collection, user, permissions, groupUpdateAuthority, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const permissionsAccountAddress = getCollectionWideUserPermissionsAddress(collection, user);
        const metadataProgram = connector.type === "program" ? connector.metadataProgram : yield (0, programs_1.loadMetadataProgram)(connector.provider);
        const existingPermissionsInfo = yield metadataProgram.provider.connection.getAccountInfo(permissionsAccountAddress);
        const anchorPermissions = permissions.map(convertPermission);
        if (!existingPermissionsInfo) {
            return metadataProgram.methods.delegateCollectionPermissions({
                permissions: anchorPermissions,
            }).accounts({
                collection,
                delegatedUser: user,
                systemProgram: web3_js_1.SystemProgram.programId,
                updateAuthority: groupUpdateAuthority,
                userPermissions: permissionsAccountAddress
            });
        }
        return metadataProgram.methods.updatePermissions({
            permissions: anchorPermissions
        }).accounts({
            updateAuthority: groupUpdateAuthority,
            user: user,
            userPermissions: permissionsAccountAddress
        });
    });
}
exports.setUserPermissionsForGroup = setUserPermissionsForGroup;
