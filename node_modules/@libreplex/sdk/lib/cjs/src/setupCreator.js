"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupCreator = exports.setupCreatorWithCustomSalePhases = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const pda_1 = require("./pda");
const groupPermissions_1 = require("./groupPermissions");
const creatorControls_1 = require("./creatorControls");
const constants_1 = require("./constants");
function setupCreatorWithCustomSalePhases(input, creatorControllerProgram, salePhases, checkGroupIsValid = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const me = creatorControllerProgram.provider.publicKey;
        const setupCreatorCtx = yield setupCreator(input, checkGroupIsValid);
        const creatorControllerSeed = web3_js_1.Keypair.generate();
        const anchorPhases = salePhases.map(p => {
            const anchorControls = p.control.map(creatorControls_1.controlToAnchor);
            return {
                start: new anchor_1.BN(Math.floor(p.start.getTime() / 1000)),
                end: p.end != null ? new anchor_1.BN(Math.floor(p.end.getTime() / 1000)) : null,
                label: p.label,
                controls: anchorControls,
            };
        });
        const creatorController = (0, pda_1.getCreatorControllerAddress)(creatorControllerSeed.publicKey);
        const controllerCtx = yield creatorControllerProgram.methods.initialize({
            seed: creatorControllerSeed.publicKey,
            phases: anchorPhases
        }).accounts({
            creator: setupCreatorCtx.creator,
            creatorController,
            libreplexCreatorProgram: constants_1.LIBREPLEX_CREATOR_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
            updateAuthority: me,
            payer: me,
        }).prepare();
        const method = setupCreatorCtx.method.postInstructions([controllerCtx.instruction]);
        return {
            method,
            creatorController,
            creator: setupCreatorCtx.creator,
            minterNumbers: setupCreatorCtx.minterNumbers,
        };
    });
}
exports.setupCreatorWithCustomSalePhases = setupCreatorWithCustomSalePhases;
function setupCreator(input, checkGroupIsValid = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const { program, collection, creatorData, mintAuthority, metadataProgram } = input;
        const { description, baseName, ordered, supply, symbol, baseUrl } = creatorData;
        const me = program.provider.publicKey;
        if (checkGroupIsValid) {
            const groupAccount = yield metadataProgram.account.collection.fetchNullable(collection);
            if (!groupAccount) {
                throw new Error("Provided group does not exist");
            }
            if (groupAccount.updateAuthority.toString() !== (me === null || me === void 0 ? void 0 : me.toString())) {
                throw new Error(`You do not have authority over the provided group. 
                ${groupAccount.updateAuthority.toString()} ${me === null || me === void 0 ? void 0 : me.toString()}`);
            }
        }
        const creatorSeed = web3_js_1.Keypair.generate();
        const creator = (0, pda_1.getCreatorAddress)(creatorSeed.publicKey);
        const preIx = [];
        const signers = [];
        let minterNumbers = null;
        if (!ordered) {
            const minterNumbersKp = web3_js_1.Keypair.generate();
            const minterNumbersSize = 8 + 32 + 4 * supply;
            const rent = yield program.provider.connection.getMinimumBalanceForRentExemption(minterNumbersSize, "confirmed");
            const creatorMinterNumbersIx = web3_js_1.SystemProgram.createAccount({
                fromPubkey: program.provider.publicKey,
                lamports: rent,
                newAccountPubkey: minterNumbersKp.publicKey,
                programId: program.programId,
                space: minterNumbersSize,
            });
            minterNumbers = minterNumbersKp.publicKey;
            preIx.push(creatorMinterNumbersIx);
            signers.push(minterNumbersKp);
        }
        let createCreatorMethod = yield program.methods.createCreator({
            attributeMappings: null,
            collection,
            description,
            isOrdered: ordered,
            maxMints: supply,
            mintAuthority,
            name: baseName,
            seed: creatorSeed.publicKey,
            symbol: symbol,
            assetUrl: baseUrl.type === "json-prefix" ? {
                jsonPrefix: {
                    url: baseUrl.url,
                }
            } : {
                chainRenderer: {
                    programId: baseUrl.programId
                }
            }
        }).accounts({
            creator,
            minterNumbers,
            signer: program.provider.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
        }).preInstructions(preIx).signers(signers);
        const delegateToGroupMethod = yield (yield (0, groupPermissions_1.setUserPermissionsForGroup)({
            collection,
            groupUpdateAuthority: me,
            user: creator,
            connector: {
                type: "program",
                metadataProgram,
            },
            permissions: [groupPermissions_1.UserPermission.AddToGroup]
        })).prepare();
        createCreatorMethod = createCreatorMethod.postInstructions([delegateToGroupMethod.instruction]);
        return {
            method: createCreatorMethod,
            creator,
            minterNumbers
        };
    });
}
exports.setupCreator = setupCreator;
