"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupLibreplexReadyMint = exports.mintSingle = exports.mintFromCreatorController = exports.mintFromCreatorControllerState = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const spl_token_1 = require("@solana/spl-token");
const buffer_layout_1 = require("@solana/buffer-layout");
const buffer_layout_utils_1 = require("@solana/buffer-layout-utils");
const pda_1 = require("./pda");
const groupPermissions_1 = require("./groupPermissions");
const programs_1 = require("./programs");
function mintFromCreatorControllerState(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const { creatorControllerProgram, creatorController, merkleProofsForAllowLists, addTransferHookToMint, minterNumbers, targetPhase, collection, creator, } = input;
        let mintKeyPair = input.mintKeyPair || web3_js_1.Keypair.generate();
        const connection = creatorControllerProgram.provider.connection;
        const me = creatorControllerProgram.provider.publicKey;
        if (!me) {
            throw new Error('Provider not setup. Perhaps your wallet is not connected');
        }
        const args = [];
        const remainingAccounts = [];
        const controls = targetPhase.controls;
        for (const control of controls) {
            if (control.payment) {
                remainingAccounts.push({
                    isSigner: false,
                    isWritable: true,
                    pubkey: control.payment[0].recepient,
                });
            }
            else if (control.splPayment) {
                remainingAccounts.push({
                    isSigner: false,
                    isWritable: true,
                    pubkey: control.splPayment[0].recepient,
                });
                remainingAccounts.push({
                    isSigner: false,
                    isWritable: true,
                    pubkey: (0, spl_token_1.getAssociatedTokenAddressSync)(control.splPayment[0].mint, me, undefined, control.splPayment[0].tokenProgram),
                });
                remainingAccounts.push({
                    isSigner: false,
                    isWritable: false,
                    pubkey: control.splPayment[0].tokenProgram,
                });
            }
            else if (control.mintLimit) {
                const seeds = [Buffer.from('mint_limit')];
                if (control.mintLimit[0].scopedToBuyer) {
                    seeds.push(me.toBuffer());
                }
                control.mintLimit[0].accountKey.forEach((keyElement) => {
                    seeds.push(keyElement.toBuffer());
                });
                const mintLimitAccount = web3_js_1.PublicKey.findProgramAddressSync(seeds, constants_1.LIBREPLEX_CREATOR_CONTROLS_PROGRAM_ID)[0];
                remainingAccounts.push({
                    isSigner: false,
                    isWritable: true,
                    pubkey: mintLimitAccount,
                });
            }
            else if (control.allowList) {
                if (!merkleProofsForAllowLists) {
                    throw new Error('Must provide merkle proofs when your creator as an allowlist');
                }
                const proofEntry = merkleProofsForAllowLists.find((mp) => mp.label === control.allowList[0].label);
                if (!proofEntry) {
                    throw new Error(`Proof entry not found for allowlist: ${control.allowList[0].label}`);
                }
                args.push(Buffer.concat(proofEntry.proof));
            }
            else if (control.customProgram) {
                const remainingAccountMetas = [
                    {
                        isSigner: false,
                        isWritable: false,
                        pubkey: control.customProgram[0].programId,
                    },
                ];
                for (const meta of control.customProgram[0].remainingAccountMetas) {
                    const key = meta.key;
                    if (key.pubkey) {
                        remainingAccountMetas.push(Object.assign(Object.assign({}, meta), { pubkey: key.pubkey[0] }));
                    }
                    else if (key.derivedFromSeeds) {
                        const programId = key.derivedFromSeeds[0].programId;
                        const seeds = [];
                        for (const seed of key.derivedFromSeeds[0].seeds) {
                            if (seed.bytes) {
                                seeds.push(seed.bytes[0]);
                            }
                            else if (seed.mintPlaceHolder) {
                                seeds.push(mintKeyPair.publicKey.toBuffer());
                            }
                            else if (seed.payerPlaceHolder || seed.receiverPlaceHolder) {
                                seeds.push(me.toBuffer());
                            }
                            else {
                                throw new Error('Invalid seed derivation');
                            }
                        }
                        remainingAccountMetas.push(Object.assign(Object.assign({}, meta), { pubkey: web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0] }));
                    }
                    else {
                        throw new Error('Invalid CustomProgramAcountMetaKey');
                    }
                }
                remainingAccounts.push(...remainingAccountMetas);
            }
        }
        const metadata = (0, pda_1.getMetadataAddress)(mintKeyPair.publicKey);
        const setupMintCtx = yield setupLibreplexReadyMint(connection, me, me, me, me, 0, mintKeyPair, metadata, addTransferHookToMint);
        return {
            method: creatorControllerProgram.methods
                .mint({
                chosenPhase: targetPhase.label,
                args,
            })
                .accounts({
                attributeConfig: null,
                creator,
                creatorController,
                collection,
                libreplexCreatorProgram: constants_1.LIBREPLEX_CREATOR_PROGRAM_ID,
                libreplexMetadataProgram: constants_1.LIBREPLEX_METADATA_PROGRAM_ID,
                libreplexNftProgram: constants_1.LIBREPLEX_NFT_PROGRAM_ID,
                mint: mintKeyPair.publicKey,
                metadata,
                mintAuthority: me,
                minterNumbers,
                mintWrapper: (0, pda_1.getMintWrapperAddress)(mintKeyPair.publicKey),
                payer: me,
                receiver: me,
                receiverTokenAccount: (0, spl_token_1.getAssociatedTokenAddressSync)(mintKeyPair.publicKey, me, undefined, spl_token_1.TOKEN_2022_PROGRAM_ID),
                recentSlothashes: web3_js_1.SYSVAR_SLOT_HASHES_PUBKEY,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: spl_token_1.TOKEN_2022_PROGRAM_ID,
                collectionPermissions: (0, groupPermissions_1.getCollectionWideUserPermissionsAddress)(collection, creator),
            })
                .preInstructions([...setupMintCtx.transaction.instructions])
                .signers([mintKeyPair])
                .remainingAccounts(remainingAccounts),
            mint: mintKeyPair,
        };
    });
}
exports.mintFromCreatorControllerState = mintFromCreatorControllerState;
function mintFromCreatorController(input) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { creatorControllerProgram, creatorController, creatorProgram, phaseToMintIn, } = input;
        const controller = yield creatorControllerProgram.account.creatorController.fetchNullable(creatorController);
        if (!controller) {
            throw new Error(`Creator controller at address: ${creatorController.toString()} not found`);
        }
        const creator = yield creatorProgram.account.creator.fetchNullable(controller.creator);
        if (!creator) {
            throw new Error(`Creator at address ${(_a = controller.creator) === null || _a === void 0 ? void 0 : _a.toString()} not found`);
        }
        const now = Date.now() / 1000;
        const availableSalePhases = controller.phases;
        const activePhases = availableSalePhases.filter((ph) => now > ph.start && (ph.end === null || now < ph.end));
        if (activePhases.length === 0) {
            throw new Error('No currently active phases to mint from');
        }
        let targetPhase = activePhases[0];
        if (activePhases.length > 1) {
            if (!phaseToMintIn) {
                throw new Error('Must provide a target phase to mint in when multiple are active');
            }
            const maybeTargetPhase = activePhases.find((ph) => ph.label === phaseToMintIn);
            if (!maybeTargetPhase) {
                throw new Error(`Specified phase to mint in ${phaseToMintIn} is not active`);
            }
            targetPhase = maybeTargetPhase;
        }
        return mintFromCreatorControllerState(Object.assign(Object.assign({}, input), { targetPhase, creator: controller.creator, minterNumbers: creator.minterNumbers, collection: creator.collection }));
    });
}
exports.mintFromCreatorController = mintFromCreatorController;
function mintSingle(input) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { provider, metadataProgram = yield (0, programs_1.loadMetadataProgram)(provider), nftProgram = yield (0, programs_1.loadNftProgram)(provider), mintToCollection, receiver = provider.publicKey, mintKp = web3_js_1.Keypair.generate(), transferHook, updateAuthority = provider.publicKey, mintData, } = input;
        const me = provider.publicKey;
        if (!me) {
            throw new Error('Provider does have a wallet loaded into it. Are you sure your wallet is connected');
        }
        if (mintToCollection) {
            if (mintToCollection.checkValidGroup) {
                const groupData = yield metadataProgram.account.collection.fetchNullable(mintToCollection.collection);
                if (!groupData) {
                    throw new Error('Group does not exist');
                }
                if (groupData.updateAuthority.toString() != me.toString()) {
                    const groupWideAddress = (0, groupPermissions_1.getCollectionWideUserPermissionsAddress)(mintToCollection.collection, me);
                    const permissionsData = yield metadataProgram.account.delegatePermissions.fetchNullable(groupWideAddress);
                    const hasDelegatedPermission = !!(permissionsData === null || permissionsData === void 0 ? void 0 : permissionsData.permissions.find((perm) => !!perm.addToGroup));
                    if (!permissionsData || !hasDelegatedPermission) {
                        throw new Error('You do not have permission to add metadata to this group.');
                    }
                    mintToCollection.groupDelegate = true;
                }
            }
        }
        const connection = provider.connection;
        const metadata = (0, pda_1.getMetadataAddress)(mintKp.publicKey);
        const mintCtx = yield setupLibreplexReadyMint(connection, me, me, receiver, me, 0, mintKp, metadata, transferHook);
        let anchorAssetUrl;
        const { assetUrl, name, symbol } = mintData;
        switch (assetUrl.type) {
            case 'jsonUrl':
                anchorAssetUrl = {
                    json: {
                        url: assetUrl.value,
                    },
                };
                break;
            case 'imageUrl':
                anchorAssetUrl = {
                    image: {
                        url: assetUrl.value,
                        description: null,
                    },
                };
                break;
            case 'renderedOnChain':
                anchorAssetUrl = {
                    chainRenderer: {
                        programId: assetUrl.programId,
                    },
                };
                break;
            default:
                throw new Error('Invalid asset type');
        }
        let extensions = [];
        if (mintData.extension) {
            if (mintData.extension.onChainAttributes) {
                extensions.push({
                    attributes: {
                        attributes: Buffer.from((_a = mintData.extension.onChainAttributes) !== null && _a !== void 0 ? _a : []),
                    },
                });
            }
            if (mintData.extension.royalties) {
                extensions.push({
                    royalties: {
                        royalties: mintData.extension.royalties || null,
                    },
                });
            }
            if (mintData.extension.licenseUrl) {
                extensions.push({
                    license: {
                        license: {
                            custom: {
                                licenseUrl: mintData.extension.licenseUrl,
                            },
                        },
                    },
                });
            }
            if (mintData.extension.permittedSigners) {
                extensions.push({
                    signers: {
                        signers: mintData.extension.permittedSigners || [],
                    },
                });
            }
        }
        console.log('Creating metadata instructions');
        const createMetaData = metadataProgram.methods
            .createMetadata({
            asset: anchorAssetUrl,
            extensions,
            name,
            symbol,
            updateAuthority: updateAuthority,
        })
            .accounts({
            authority: me,
            metadata,
            payer: me,
            mint: mintKp.publicKey,
            invokedMigratorProgram: null,
            systemProgram: web3_js_1.SystemProgram.programId,
        })
            .preInstructions(mintCtx.transaction.instructions)
            .signers([mintCtx.keypair]);
        console.log('Created metadata instruction');
        const postIxs = [
            yield nftProgram.methods
                .wrap()
                .accounts({
                authority: me,
                mint: mintKp.publicKey,
                payer: me,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: spl_token_1.TOKEN_2022_PROGRAM_ID,
                wrappedMint: (0, pda_1.getMintWrapperAddress)(mintKp.publicKey),
            })
                .instruction(),
        ];
        if (mintToCollection) {
            const ix = yield metadataProgram.methods
                .addMetadataToCollection()
                .accounts({
                delegatedCollectionWidePermissions: mintToCollection.groupDelegate
                    ? (0, groupPermissions_1.getCollectionWideUserPermissionsAddress)(mintToCollection.collection, me)
                    : null,
                systemProgram: web3_js_1.SystemProgram.programId,
                payer: me,
                metadata,
                metadataAuthority: me,
                collectionAuthority: me,
                delegatedMetadataSpecificPermissions: null,
                collection: mintToCollection.collection,
            })
                .instruction();
            postIxs.push(ix);
        }
        return {
            method: createMetaData.postInstructions(postIxs),
            mint: mintKp,
        };
    });
}
exports.mintSingle = mintSingle;
const MetadataPointerMintSize = 234;
const MintSizeForTranserHookAndPointer = 302;
const initializeMetadataPointerInstructionData = (0, buffer_layout_1.struct)([
    (0, buffer_layout_1.u8)('instruction'),
    (0, buffer_layout_1.u8)('metadataPointerInitIx'),
    (0, buffer_layout_utils_1.publicKey)('authority'),
    (0, buffer_layout_utils_1.publicKey)('metadataAddress'),
]);
const initializeTransferHookInitInstructionData = (0, buffer_layout_1.struct)([
    (0, buffer_layout_1.u8)('instruction'),
    (0, buffer_layout_1.u8)('transferHookInstruction'),
    (0, buffer_layout_utils_1.publicKey)('authority'),
    (0, buffer_layout_utils_1.publicKey)('transferHookProgramId'),
]);
function setupLibreplexReadyMint(connection, payer, receiver, mintAuthority, freezeAuthority, decimals, mintKeypair = web3_js_1.Keypair.generate(), metadata, transferHook, programId = spl_token_1.TOKEN_2022_PROGRAM_ID) {
    return __awaiter(this, void 0, void 0, function* () {
        const mintSize = transferHook
            ? MintSizeForTranserHookAndPointer
            : MetadataPointerMintSize;
        const lamports = yield connection.getMinimumBalanceForRentExemption(mintSize);
        const initMetadataPointerExtensionIx = (() => {
            const initMetadataPointerIxSpan = Buffer.alloc(initializeMetadataPointerInstructionData.span);
            initializeMetadataPointerInstructionData.encode({
                instruction: 39,
                authority: web3_js_1.PublicKey.default,
                metadataPointerInitIx: 0,
                metadataAddress: metadata,
            }, initMetadataPointerIxSpan);
            return new web3_js_1.TransactionInstruction({
                keys: [
                    {
                        isSigner: false,
                        isWritable: true,
                        pubkey: mintKeypair.publicKey,
                    },
                ],
                programId,
                data: initMetadataPointerIxSpan,
            });
        })();
        const preInitMintIxs = [];
        if (transferHook) {
            const accounts = [
                { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: true },
            ];
            const transferHookIxBuf = Buffer.alloc(initializeTransferHookInitInstructionData.span);
            initializeTransferHookInitInstructionData.encode({
                authority: transferHook.authority,
                transferHookProgramId: transferHook.programId,
                instruction: 36,
                transferHookInstruction: 0,
            }, transferHookIxBuf);
            preInitMintIxs.push(new web3_js_1.TransactionInstruction({
                keys: accounts,
                programId: spl_token_1.TOKEN_2022_PROGRAM_ID,
                data: transferHookIxBuf,
            }));
        }
        const assocTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(mintKeypair.publicKey, receiver, undefined, spl_token_1.TOKEN_2022_PROGRAM_ID);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
            fromPubkey: payer,
            newAccountPubkey: mintKeypair.publicKey,
            space: mintSize,
            lamports,
            programId,
        }), initMetadataPointerExtensionIx, ...preInitMintIxs, (0, spl_token_1.createInitializeMint2Instruction)(mintKeypair.publicKey, decimals, mintAuthority, freezeAuthority, programId), (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, assocTokenAccount, receiver, mintKeypair.publicKey, spl_token_1.TOKEN_2022_PROGRAM_ID), (0, spl_token_1.createMintToInstruction)(mintKeypair.publicKey, assocTokenAccount, mintAuthority, 1, undefined, spl_token_1.TOKEN_2022_PROGRAM_ID));
        return {
            transaction,
            keypair: mintKeypair,
        };
    });
}
exports.setupLibreplexReadyMint = setupLibreplexReadyMint;
