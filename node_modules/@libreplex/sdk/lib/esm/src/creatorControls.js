export function anchorToControl(c) {
    if (c.allowList) {
        return {
            name: "AllowList",
            label: c.allowList[0].label,
            merkleRoot: c.allowList[0].root
        };
    }
    if (c.customProgram) {
        return {
            name: "CustomProgram",
            instructionData: c.customProgram[0].instructionData,
            label: c.customProgram[0].label,
            programId: c.customProgram[0].programId,
            remainingAccountsMetas: c.customProgram[0].remainingAccountMetas.map(m => {
                let anchorKey = m.key;
                let key;
                if (anchorKey.pubkey) {
                    key = {
                        type: "key",
                        value: anchorKey.pubkey[0]
                    };
                }
                else if (anchorKey.derivedFromSeeds) {
                    const anchorSeeds = anchorKey.derivedFromSeeds[0].seeds;
                    const seeds = [];
                    for (let anchorSeed of anchorSeeds) {
                        if (anchorSeed.bytes) {
                            seeds.push({
                                type: "bytes",
                                value: anchorSeed.bytes[0]
                            });
                        }
                        else if (anchorSeed.mintPlaceHolder) {
                            seeds.push({
                                type: "mintPlaceHolder",
                            });
                        }
                        else if (anchorSeed.payerPlaceHolder) {
                            seeds.push({
                                type: "payerPlaceHolder",
                            });
                        }
                        else if (anchorSeed.receiverPlaceHolder) {
                            seeds.push({
                                type: "receiverPlaceHolder",
                            });
                        }
                        else {
                            throw new Error("Unsupported custom program anchor seed.");
                        }
                    }
                    key = {
                        type: "seedDerivation",
                        seeds,
                        programId: anchorKey.derivedFromSeeds[0].programId,
                    };
                }
                else {
                    throw new Error("Unsupported custom program anchor key.");
                }
                return {
                    isSigner: m.isSigner,
                    isWritable: m.isWritable,
                    key,
                };
            }),
        };
    }
    if (c.mintLimit) {
        return {
            name: "MintLimitControl",
            amount: c.mintLimit[0].limit,
            extraSeeds: c.mintLimit[0].accountKey,
            scopedToBuyer: c.mintLimit[0].scopedToBuyer,
        };
    }
    if (c.payment) {
        const control = c.payment[0];
        return {
            name: "SolPayment",
            price: control.amount,
            receiver: control.recepient
        };
    }
    if (c.splPayment) {
        const control = c.splPayment[0];
        return {
            name: "SplPayment",
            amount: control.amount,
            mint: control.mint,
            recepient: control.recepient,
            tokenProgram: control.tokenProgram
        };
    }
    throw new Error("Tried to convert invalid anchor control");
}
export function controlToAnchor(c) {
    switch (c.name) {
        case "SolPayment":
            return {
                payment: {
                    0: {
                        amount: c.price,
                        recepient: c.receiver,
                    }
                }
            };
        case "AllowList":
            return {
                allowList: {
                    "0": {
                        root: c.merkleRoot,
                        label: c.label,
                    }
                }
            };
        case "CustomProgram":
            const remainingAccountMetas = [];
            for (let meta of c.remainingAccountsMetas) {
                let key;
                switch (meta.key.type) {
                    case "key":
                        key = {
                            pubkey: {
                                "0": meta.key.value,
                            }
                        };
                        break;
                    case "seedDerivation":
                        const seeds = [];
                        for (const seed of meta.key.seeds) {
                            switch (seed.type) {
                                case "bytes":
                                    seeds.push({
                                        bytes: {
                                            "0": seed.value
                                        }
                                    });
                                    break;
                                case "mintPlaceHolder":
                                    seeds.push({
                                        mintPlaceHolder: {}
                                    });
                                    break;
                                case "receiverPlaceHolder":
                                    seeds.push({
                                        receiverPlaceHolder: {}
                                    });
                                    break;
                                case "payerPlaceHolder":
                                    seeds.push({
                                        payerPlaceHolder: {}
                                    });
                                    break;
                                default:
                                    throw new Error(`Invalid seed ${seed}`);
                            }
                        }
                        key = {
                            derivedFromSeeds: {
                                "0": {
                                    programId: meta.key.programId,
                                    seeds,
                                }
                            }
                        };
                        break;
                    default:
                        throw new Error(`Invalid custom program account meta key type. ${meta.key}`);
                }
                remainingAccountMetas.push({
                    isSigner: meta.isSigner,
                    isWritable: meta.isWritable,
                    key,
                });
            }
            return {
                customProgram: {
                    0: {
                        ...c,
                        remainingAccountMetas
                    }
                }
            };
        case "MintLimitControl":
            return {
                mintLimit: {
                    "0": {
                        limit: c.amount,
                        scopedToBuyer: c.scopedToBuyer,
                        accountKey: c.extraSeeds,
                    }
                }
            };
        case "SplPayment":
            return {
                splPayment: {
                    "0": c
                }
            };
        default:
            throw new Error("Invalid control");
    }
    ;
}
//# sourceMappingURL=creatorControls.js.map